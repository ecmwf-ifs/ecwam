! (C) Copyright 1989- ECMWF.
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

SUBROUTINE GETGRBOBSTRCT(BLK2GLO, BLK2LOC, IREAD, NPR, FILNM, KFILE_HANDLE, KGRIB_HANDLE)

!****  *GETGRBOBSTRCT* - DETERMINES OBSTRUCTION COEFFICIENTS FROM GRIB INPUT 

! -------------------------------------------------------------------

USE PARKIND_WAVE, ONLY : JWIM, JWRB, JWRU
USE YOWDRVTYPE  , ONLY : WVGRIDGLO, WVGRIDLOC, FORCING_FIELDS

USE YOWABORT , ONLY : WAM_ABORT
USE YOWGRIBINFO, ONLY : WVGETGRIDINFO
USE YOWGRID  , ONLY : NPROMA_WAM
USE YOWMAP   , ONLY : NGX, NGY, IPER, IRGG, IQGAUSS,                        &
                   &  DAMOWEP, DAMOSOP, DAMOEAP, DAMONOP, DXDELLA, DXDELLO, &
                   &  NLONRGG
USE YOWMPP   , ONLY : IRANK
USE YOWPARAM , ONLY : NFRE_RED
USE YOWPCONS , ONLY : ZMISS
USE YOWSTAT  , ONLY : IPROPAGS, LSUBGRID
USE YOWSPEC  , ONLY : NSTART, NEND
USE YOWTEST  , ONLY : IU06
USE YOWUBUF  , ONLY : OBSLAT, OBSLON, OBSCOR, OBSRLAT, OBSRLON,  &
                    & NPROPAGS, NANG_OBS, KTOIS, KTOOBSTRUCT
USE YOWWIND  , ONLY : NXFFS_LOC, NXFFE_LOC, NYFFS_LOC, NYFFE_LOC

USE YOWGRIB  , ONLY : IGRIB_GET_VALUE, IGRIB_CLOSE_FILE, IGRIB_RELEASE
USE EC_LUN   , ONLY : NULERR
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK, JPHOOK

!----------------------------------------------------------------------

IMPLICIT NONE

#include "init_fieldg.intfb.h"
#include "inwgrib.intfb.h"
#include "ktoobs.intfb.h"
#include "wvchkmid.intfb.h"

TYPE(WVGRIDGLO), INTENT(IN)       :: BLK2GLO       !! POINTERS FROM GLOBAL GRID POINTS TO 2-D MAP
TYPE(WVGRIDLOC), INTENT(IN)       :: BLK2LOC       !! POINTERS FROM LOCAL GRID POINTS TO 2-D MAP
INTEGER(KIND=JWIM), INTENT(IN)    :: IREAD         !! PE READING THE GRIB FILE
INTEGER(KIND=JWIM), INTENT(IN)    :: NPR           !! NUMBER OF SUBDOMAINS (USUALLY THE NUMBER OF PE'S )
CHARACTER(LEN=*),   INTENT(IN)    :: FILNM         !! FILENAME ASSOCIATED TO GRIB HANDLES
INTEGER(KIND=JWIM), INTENT(INOUT) :: KFILE_HANDLE  !! GRIB FILE HANDLE CONNECTED TO SUB GRIB BATHY INPUT
INTEGER(KIND=JWIM), INTENT(INOUT) :: KGRIB_HANDLE  !! GRIB HANDLE CONNECTED TO SUB GRIB BATHY INPUT

INTEGER(KIND=JWIM) :: IJ, M, K, IS, IX, IY
INTEGER(KIND=JWIM) :: IPARAM, KZLEV, IANGNB, IFRENB, IOBSRT, IFILE_HANDLE 
INTEGER(KIND=JWIM) :: IRET, IERR, IEDITION
INTEGER(KIND=JWIM) :: NGX_SUB, NGY_SUB, IPER_SUB, IRGG_SUB, IQGAUSS_SUB
INTEGER(KIND=JWIM) :: JKGLO, KIJS, KIJL
INTEGER(KIND=JWIM), ALLOCATABLE, DIMENSION(:) :: NLONRGG_SUB

REAL(KIND=JPHOOK) :: ZHOOK_HANDLE

REAL(KIND=JWRU) ::  AMOWEP_SUB, AMOSOP_SUB, AMOEAP_SUB, AMONOP_SUB, XDELLA_SUB, XDELLO_SUB

REAL(KIND=JWRB), ALLOCATABLE, DIMENSION(:,:) :: FIELD

! INPUT FORCING FIELDS ON THE WAVE MODEL GRID:
TYPE(FORCING_FIELDS) :: FIELDG

CHARACTER(LEN= 14) :: CDATE

LOGICAL :: LLSCANNS_SUB, LLSAMEGRID
LOGICAL :: LLINIALL, LLOCAL, LLFIX, LLCHK

!----------------------------------------------------------------------

IF (LHOOK) CALL DR_HOOK('GETGRBOBSTRCT',0,ZHOOK_HANDLE)

LLSAMEGRID = .TRUE.


! OBSTRUCTION COEFFICIENTS
! NOTE: THEIR VALUES WILL BE RESET IN THE FIRST
! CALL TO PROPAGS TO CONTAIN THE OBSTRUCTION TIME THE GROUP
! VELOCITY At THE INTERFACE !!!!!!!!

IF (ALLOCATED(OBSLON)) DEALLOCATE(OBSLON)
ALLOCATE(OBSLON(NSTART(IRANK):NEND(IRANK),NFRE_RED,2))

IF (ALLOCATED(OBSLAT)) DEALLOCATE(OBSLAT)
ALLOCATE(OBSLAT(NSTART(IRANK):NEND(IRANK),NFRE_RED,2))

IF (IPROPAGS == 1) THEN
  IF (ALLOCATED(OBSRLON)) DEALLOCATE(OBSRLON)
  ALLOCATE(OBSRLON(NSTART(IRANK):NEND(IRANK),NFRE_RED,2))
  IF (ALLOCATED(OBSRLAT)) DEALLOCATE(OBSRLAT)
  ALLOCATE(OBSRLAT(NSTART(IRANK):NEND(IRANK),NFRE_RED,2))
ENDIF

IF (IPROPAGS == 2) THEN
  IF (ALLOCATED(OBSCOR)) DEALLOCATE(OBSCOR)
  ALLOCATE(OBSCOR(NSTART(IRANK):NEND(IRANK),NFRE_RED,4))
ENDIF


IF ( LSUBGRID ) THEN

  CALL KTOOBS(IU06)

  ! INWGRIB REQUIRES FIELDG
  CALL FIELDG%ALLOC(LBOUNDS=[NXFFS_LOC, NYFFS_LOC], UBOUNDS=[NXFFE_LOC, NYFFE_LOC])

  LLINIALL=.FALSE.
  LLOCAL=.FALSE.
  CALL INIT_FIELDG(BLK2LOC, LLINIALL, LLOCAL,                           &
 &                 NXFFS_LOC, NXFFE_LOC, NYFFS_LOC, NYFFE_LOC, FIELDG)


  ! BEFORE LOOPING OVER ALL FREQUENCIES, CHECK THAT THE SUBGRID DATA ARE FOR THE SAME GRID
  ! (we will only check the first entry)
  IF (IRANK == IREAD) THEN

    CALL WVCHKMID(IU06, KGRIB_HANDLE,__FILENAME__)

    CALL WVGETGRIDINFO(IU06, KGRIB_HANDLE, &
 &                     NGX_SUB, NGY_SUB, IPER_SUB, IRGG_SUB, IQGAUSS_SUB, NLONRGG_SUB, LLSCANNS_SUB, &
 &                     AMOWEP_SUB, AMOSOP_SUB, AMOEAP_SUB, AMONOP_SUB, XDELLA_SUB, XDELLO_SUB )

    !! Check that it is the same as input BATHY
    CALL IGRIB_GET_VALUE(KGRIB_HANDLE,'editionNumber', IEDITION, IERR)

    IF ( IEDITION == 1 ) THEN
      !! Until we can use the grib2 template for spectra,
      !! we need to limit what can be compared with the grib2 BATHY
      IF ( NGX_SUB /= NGX .OR. NGY_SUB /= NGY .OR. IPER_SUB .NE. IPER .OR. IQGAUSS_SUB .NE. IQGAUSS ) THEN
        LLSAMEGRID = .FALSE.
      ENDIF
    ELSE
      IF ( NGX_SUB /= NGX .OR. NGY_SUB /= NGY .OR. IPER_SUB .NE. IPER .OR. IQGAUSS_SUB .NE. IQGAUSS .OR. &
 &         AMOWEP_SUB /= DAMOWEP .OR. AMOSOP_SUB /= DAMOSOP .OR. AMOEAP_SUB /= DAMOEAP .OR. &
 &          AMONOP_SUB /= DAMONOP .OR. XDELLA_SUB /= DXDELLA .OR. XDELLO_SUB /= DXDELLO ) THEN
        LLSAMEGRID = .FALSE.
      ENDIF
    ENDIF

    IF ( LLSAMEGRID ) THEN
      DO K = 1, NGY
        IF (NLONRGG_SUB(MIN(K,NGY_SUB)) /= NLONRGG(K) ) THEN
            LLSAMEGRID = .FALSE.
           EXIT
        ENDIF
      ENDDO
    ENDIF

    IF( .NOT. LLSAMEGRID ) THEN
      WRITE(NULERR,*) "GETGRBOBSTRCT : " 
      WRITE(NULERR,*) "MEAN AND SUBGRIB BATHYMETRY DO NOT HAVE THE SAME GRID !" 
      WRITE(IU06,*) "GETGRBOBSTRCT : " 
      WRITE(IU06,*) "MEAN AND SUBGRIB BATHYMETRY DO NOT HAVE THE SAME GRID !" 
      WRITE(IU06,*)  NGX, NGY, IPER, IRGG, IQGAUSS
      WRITE(IU06,*)  NGX_SUB, NGY_SUB, IPER_SUB, IRGG_SUB, IQGAUSS_SUB
      DO K = 1, NGY
        WRITE(IU06,*)  K, NLONRGG(K), NLONRGG_SUB(MIN(K,NGY_SUB))
      ENDDO
      WRITE(IU06,*) DAMOWEP, DAMOSOP, DAMOEAP, DAMONOP, DXDELLA, DXDELLO
      WRITE(IU06,*) AMOWEP_SUB, AMOSOP_SUB, AMOEAP_SUB, AMONOP_SUB, XDELLA_SUB, XDELLO_SUB
      CALL FLUSH(IU06)
      CALL WAM_ABORT("Not same grid !",__FILENAME__,__LINE__)
    ENDIF

    CALL IGRIB_CLOSE_FILE(KFILE_HANDLE)
    CALL IGRIB_RELEASE(KGRIB_HANDLE)

  ENDIF


  ALLOCATE(FIELD(NXFFS_LOC:NXFFE_LOC, NYFFS_LOC:NYFFE_LOC))
  IFILE_HANDLE = -99

  LLFIX = .TRUE.

  LLCHK = .FALSE. !! the subgrid data are on the same grid as the model (see check above)

  DO M = 1, NFRE_RED ! loop over frequencies

    DO K = 1, NANG_OBS

      ! Get grib data (read, distribute and decode):
      CALL INWGRIB (FILNM, IREAD, CDATE, IPARAM, KZLEV,                          &
 &                  NXFFS_LOC, NXFFE_LOC, NYFFS_LOC, NYFFE_LOC, FIELDG, FIELD,   &
 &                  LLCHKINT=LLCHK, LLFIXEDSIZE=LLFIX, NPR=NPR,                  &
 &                  KANGNB=IANGNB, KFRENB=IFRENB, NFILE_HANDLE=IFILE_HANDLE)


      IF ( IANGNB /= K .OR. IFRENB /= M ) THEN
        WRITE(IU06,*) "GETGRBOBSTRCT : "
        WRITE(IU06,*) "INPUT OBSTRUCTIONS NOT IN THE EXPECTED ORDER !"
        WRITE(IU06,*) "IANGNB, K = ", IANGNB, K
        WRITE(IU06,*) "IFRENB, M = ", IFRENB, M
        CALL FLUSH(IU06)
        CALL WAM_ABORT("Obstruction input is NOT in the expected order !",__FILENAME__,__LINE__)
      ENDIF


      IS = KTOIS(K,IPROPAGS)
      IF ( IS > 0 ) THEN
        IOBSRT = KTOOBSTRUCT(K,IPROPAGS)
        SELECT CASE(IOBSRT)

        CASE(1)
          CALL GSTATS(1498,0)
!$OMP     PARALLEL DO SCHEDULE(STATIC) PRIVATE(JKGLO, KIJS, KIJL, IJ, IX, IY)
          DO JKGLO = NSTART(IRANK), NEND(IRANK), NPROMA_WAM
            KIJS=JKGLO
            KIJL=MIN(KIJS+NPROMA_WAM-1, NEND(IRANK))
            DO IJ = KIJS, KIJL
              IX = BLK2GLO%IXLG(IJ)
              IY = NGY- BLK2GLO%KXLT(IJ) +1
              IF (FIELD(IX,IY) /= ZMISS) THEN
                OBSLAT(IJ,M,IS) = FIELD(IX,IY)
              ELSE
                OBSLAT(IJ,M,IS) = 1.0_JWRB
              ENDIF
            ENDDO
          ENDDO
!$OMP     END PARALLEL DO
          CALL GSTATS(1498,1)

        CASE(2)
          CALL GSTATS(1498,0)
!$OMP     PARALLEL DO SCHEDULE(STATIC) PRIVATE(JKGLO, KIJS, KIJL, IJ, IX, IY)
          DO JKGLO = NSTART(IRANK), NEND(IRANK), NPROMA_WAM
            KIJS=JKGLO
            KIJL=MIN(KIJS+NPROMA_WAM-1, NEND(IRANK))
            DO IJ = KIJS, KIJL
              IX = BLK2GLO%IXLG(IJ)
              IY = NGY- BLK2GLO%KXLT(IJ) +1
              IF (FIELD(IX,IY) /= ZMISS) THEN
                OBSLON(IJ,M,IS) = FIELD(IX,IY)
              ELSE
                OBSLON(IJ,M,IS) = 1.0_JWRB
              ENDIF
            ENDDO
          ENDDO
!$OMP     END PARALLEL DO
          CALL GSTATS(1498,1)

        CASE(3)
          CALL GSTATS(1498,0)
!$OMP     PARALLEL DO SCHEDULE(STATIC) PRIVATE(JKGLO, KIJS, KIJL, IJ, IX, IY)
          DO JKGLO = NSTART(IRANK), NEND(IRANK), NPROMA_WAM
            KIJS=JKGLO
            KIJL=MIN(KIJS+NPROMA_WAM-1, NEND(IRANK))
            DO IJ = KIJS, KIJL
              IX = BLK2GLO%IXLG(IJ)
              IY = NGY- BLK2GLO%KXLT(IJ) +1
              IF (FIELD(IX,IY) /= ZMISS) THEN
                OBSRLAT(IJ,M,IS) = FIELD(IX,IY)
              ELSE
                OBSRLAT(IJ,M,IS) = 1.0_JWRB
              ENDIF
            ENDDO
          ENDDO
!$OMP     END PARALLEL DO
          CALL GSTATS(1498,1)

        CASE(4)
          CALL GSTATS(1498,0)
!$OMP     PARALLEL DO SCHEDULE(STATIC) PRIVATE(JKGLO, KIJS, KIJL, IJ, IX, IY)
          DO JKGLO = NSTART(IRANK), NEND(IRANK), NPROMA_WAM
            KIJS=JKGLO
            KIJL=MIN(KIJS+NPROMA_WAM-1, NEND(IRANK))
            DO IJ = KIJS, KIJL
              IX = BLK2GLO%IXLG(IJ)
              IY = NGY- BLK2GLO%KXLT(IJ) +1
              IF (FIELD(IX,IY) /= ZMISS) THEN
                OBSRLON(IJ,M,IS) = FIELD(IX,IY)
              ELSE
                OBSRLON(IJ,M,IS) = 1.0_JWRB
              ENDIF
            ENDDO
          ENDDO
!$OMP     END PARALLEL DO
          CALL GSTATS(1498,1)

        CASE(5)
          CALL GSTATS(1498,0)
!$OMP     PARALLEL DO SCHEDULE(STATIC) PRIVATE(JKGLO, KIJS, KIJL, IJ, IX, IY)
          DO JKGLO = NSTART(IRANK), NEND(IRANK), NPROMA_WAM
            KIJS=JKGLO
            KIJL=MIN(KIJS+NPROMA_WAM-1, NEND(IRANK))
            DO IJ = KIJS, KIJL
              IX = BLK2GLO%IXLG(IJ)
              IY = NGY- BLK2GLO%KXLT(IJ) +1
              IF (FIELD(IX,IY) /= ZMISS) THEN
                OBSCOR(IJ,M,IS) = FIELD(IX,IY)
              ELSE
                OBSCOR(IJ,M,IS) = 1.0_JWRB
              ENDIF
            ENDDO
          ENDDO
!$OMP     END PARALLEL DO
          CALL GSTATS(1498,1)

        END SELECT

      ENDIF ! end loop on NANG_OBS

    ENDDO
  ENDDO ! end loop over frequencies

  DEALLOCATE(FIELD)
  IF( IFILE_HANDLE > 0 ) CALL IGRIB_CLOSE_FILE(IFILE_HANDLE)

  CALL FIELDG%DEALLOC()

  WRITE(IU06,*) ''
  WRITE(IU06,*) ' OBSTRUCTION COEFFICIENTS FROM GRIB INPUT READ IN'
  CALL FLUSH(IU06)

ELSE

  !! No obstructions. By-pass the reading of the obstruction coefficients
  OBSLAT(:,:,:) = 1.0_JWRB
  OBSLON(:,:,:) = 1.0_JWRB
  IF (IPROPAGS == 1) THEN
    OBSRLAT(:,:,:) = 1.0_JWRB
    OBSRLON(:,:,:) = 1.0_JWRB
  ENDIF
  IF (IPROPAGS == 2) THEN
    OBSCOR(:,:,:) = 1.0_JWRB
  ENDIF

ENDIF

!$acc update device(OBSLAT, OBSCOR, OBSLON)

IF (LHOOK) CALL DR_HOOK('GETGRBOBSTRCT',1,ZHOOK_HANDLE)

END SUBROUTINE GETGRBOBSTRCT
